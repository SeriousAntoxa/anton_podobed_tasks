4) Explain each result of expressions in comments:
// Описать как работают следующие выражения:
=====================================
1 - '0' + 2
// первая операция 1 - '0' => строка '0' будет преобразоваться к числу (0) потому что стоит знак минус. результат = 1
// вторая операция 1 + 2 => оба операнда одного типа значит происходит обычное сложение. результат = 3
// ответ: 3
=====================================
1 - '-0' + 2
// первая операция 1 - '-0' => строка '-0' будет преобразоваться к числу (-0) потому что стоит знак минус. результат = 1 - -0 = 1
// вторая операция 1 + 2 => оба операнда одного типа значит происходит обычное сложение. результат = 3
// ответ: 3
=====================================
1 - '-0-' + 'NaN'
// первая операция 1 - '-0-' => строка '-0-' будет преобразоваться к числу, но поскольку после 0 идет - , то мы получим NaN. При арифметических дейсвиях с NaN у нас будет NaN. результат = 1 - NaN = NaN
// вторая операция NaN + 'NaN' => второй операнд строка и здесь + приведет первый операнд тоже к строке и запишет выражение как строку. результат = 'NaNNaN'
// ответ: 'NaNNaN'
=====================================
'b' + [NaN + 'ba', 'CC'] - {};
// первая операция [NaN + 'ba', 'CC'] поскольку выше приоритет оператора []. 
// внутри массива будет выполнена операция NaN + 'ba', при сложении со строкой будет строка из двух операндов. Результат 'NaNba'
// вторая операция 'b' + ['NaNba', 'CC']. В этой операции произойдет преобразования всего что находиться в скобках [] в строку 'NaNba,CC' 
// затем конкатенация строки 'b' и 'NaNba,CC'. Результат 'bNaNba,CC'
// последняя операция 'bNaNba,CC' - {}. При преобразовании {} к числу мы получим NaN, а уже при вычитании NaN из строки мы получаем NaN. Результат NaN
// ответ: NaN
=====================================
[] + (()=>{});
// поскольку у () приоритет самый высокий, то сначало выполниться то, что находится в них и результатом будет просто выражение ()=>{}
// преобразование [] даст нам пустую строку ''
// при сложении мы получим строку вида '()=>{}'
// ответ: '()=>{}'
=====================================
[] + (()=>({}));
// поскольку у () приоритет самый высокий, то сначало выполниться то, что находится в них и результатом будет выражение ()=>({})
// преобразование [] даст нам пустую строку ''
// при сложении мы получим строку вида '()=>({})'
// ответ: '()=>({})'
=====================================
[] + (()=>({}))();
// (()=>({}))() в это выражении вначале отработают первые (()=>({})), результатом будет ()=>({})
// поскольку получается выражение это функция и следующие () вызывают ее, то результат будет пустой объект
// а при преобразовании объекта мы получим '[object Object]'
// преобразование [] даст нам пустую строку ''
// при сложении строк мы получим строку вида '[object Object]'
// ответ: '[object Object]'
=====================================
[] + (() => new Object(123))()
// (() => new Object(123))() при вызове этой функции мы получим объект Number {123} поскольку new Object(123) это просто объект-обвертка и под капотом JS new Object(123) эквивалентен new Number(123)
// преобразование [] даст нам пустую строку ''
// при сложении строки и числа мы получим строку вида '123'
// ответ: '123'
=====================================
{} + (() => new Object(123))()
// (() => new Object(123))() при вызове этой функции мы получим объект Number {123} поскольку new Object(123) это просто объект-обвертка и под капотом JS new Object(123) эквивалентен new Number(123)
// {} в начале операции читается JS как блок кода, соотсветсвенно он пустой и ничего не возвращает. Попросту говоря пустые {} игнорируются 
// у нас остается только число 123
// ответ: 123
=====================================
(() => new Object(123))() + {}
// (() => new Object(123))() при вызове этой функции мы получим объект Number {123} поскольку new Object(123) это просто объект-обвертка и под капотом JS new Object(123) эквивалентен new Number(123)
// здесь {} это уже пустой объект и при преобразовании его к строке мы получим '[object Object]'
// 123 + строка '[object Object]' по результату конкатинации мы получим строку вида '123[object Object]'
// ответ: '123[object Object]'
=====================================
({}).valueOf() + 1
// ({}).valueOf() это вражение, где valueOf() возвращает примитивное значение.
// Поскольку у нас вызов примитовного значения для объекта, то мы получаем пустой {}
// далее {} преобразовается в строку, а с объектами это результат '[object Object]'
// '[object Object]' + 1 => строка + число = 1 в строку преобразуется и получаем '[object Object]1'
// ответ: '[object Object]1'
=====================================
{} + 2
// {} в начале операции игнорируется 
// остается число 2
// ответ: 2
=====================================
typeof ({}).valueOf() + 2
// первое дейсвие ({}).valueOf() => ({}).valueOf() это вражение, где valueOf() возвращает примитивное значение.
// Поскольку у нас вызов примитовного значения для объекта, то мы получаем пустой {}
// второе дейсвие typeof {} => тип обекта это 'object'
// строка 'object' + 2 => 2 преобразует к строке и получится строка 'object2'
// ответ: 'object2'
=====================================
+{}
// здесь + выступает как преобразование к числу 
// преобразуя объект к числу мы получаем NaN
// ответ: NaN
=====================================
+{}+[]
// преобразование [] даст нам пустую строку ''
// здесь первый + выступает как преобразование к числу 
// преобразуя объект к числу мы получаем NaN
// NaN + '' => NaN преобразуется к строке и получим строку вида 'NaN' 
// ответ: 'NaN'
=====================================
+[]
// здесь + выступает как преобразование к числу 
// при преобразуя пустого массив к числу мы получаем то, что пустой массив возвращает пустую строку 
// затем пустая строка преобразуется к числу, а это число 0
// ответ: 0
=====================================
+[]+{}
// здесь первый + выступает как преобразование к числу 
// при преобразуя пустого массив к числу мы получаем то, что пустой массив возвращает пустую строку 
// затем пустая строка преобразуется к числу, а это число 0
// {} это уже пустой объект и при преобразовании его к строке мы получим '[object Object]'
// при сложение 0 и строки '[object Object]' => 0 преобразится в строку и получим строку '0[object Object]'
// ответ: '0[object Object]'
=====================================
+[10, 1]+{}
// первое действие +[10, 1] => преобразуя массив к числу мы получаем то, что массив возвращает строку '10,1'
// после чего '10,1' будет преобразованно уже к числу, где по проходу по строке '10,1' Number наткнется на ',' и не сможет преобразить в нормальное число и вернет нам NaN
// {} это уже пустой объект и при преобразовании его к строке мы получим '[object Object]'
// при сложение NaN и строки '[object Object]' => NaN преобразится в строку и получим строку 'NaN[object Object]'
// ответ: 'NaN[object Object]'
=====================================
{} + [10]
// {} в начале операции игнорируется 
// поскольку {} бл проигнорирован, то остается выражение + [10]
// [10] => преобразуя массив к числу мы получаем то, что массив возвращает строку '10'
// после чего '10' будет преобразованно уже к числу и получим число 10
// ответ: 10
=====================================