5) Explain double equal conversions in comments
// Описать как работают следующие выражения:
====================================
0 == null;
// исходя из статьи "Абстрактный алгоритм сравнения для равенств" (п22)
// ответ: false
====================================
null == undefined
// исходя из статьи "Абстрактный алгоритм сравнения для равенств" (п14)
// ответ: true
====================================
1 == {}
// исходя из статьи "Абстрактный алгоритм сравнения для равенств" 
// первое действие => поскольку у нас есть число и объект (п21), то вначале будет преобразование объекта к примитиву 
// вначале объект будет приведен к примитиву через ({}).valueOf (), что выдаст нам пустой объект {} и поскольку это не примитив все еще, то будет вызван метод ({}).toString ()
// в следствии действия ({}).toString () мы получим строку вида "[object Object]", строка это примитив
// далее запускается сравнение снова и уже сравнивается число 1 vs строка "[object Object]" (п16)
// при такой проверки строка будет преобразована к числу. Результат "[object Object]" => NaN
// операция завершена и снова начинается проверка сравнения уже 1 vs NaN
// поскольку это один тип данных, то преобразований не будет и согласно (п6) 1 не равно NaN => false
// ответ: false
====================================
{} == 1
// {} в начале операции игнорируется js (считает это за блок кода, который  у нас пустой) и мы работаем с '== 1' 
// будет ошибка, тк интрепретатор не сможет посроить абстрактное синтаксическое дерево
// ответ: SyntaxError
====================================
({}) == 1
// исходя из статьи "Абстрактный алгоритм сравнения для равенств" 
// первое действие => поскольку у нас есть число и объект (п21), то вначале будет преобразование объекта к примитиву 
// вначале объект будет приведен к примитиву через ({}).valueOf (), что выдаст нам пустой объект {} и поскольку это не примитив все еще, то будет вызван метод ({}).toString ()
// в следствии действия ({}).toString () мы получим строку вида "[object Object]", строка это примитив
// далее запускается сравнение снова и уже сравнивается число 1 vs строка "[object Object]" (п16)
// при такой проверки строка будет преобразована к числу. Результат "[object Object]" => NaN
// операция завершена и снова начинается проверка сравнения уже 1 vs NaN
// поскольку это один тип данных, то преобразований не будет и согласно (п6) 1 не равно NaN => false
// ответ: false
====================================
({toString: () => '12'}) == 12
// исходя из статьи "Абстрактный алгоритм сравнения для равенств"
// первое действие => объект будет приведен к примитиву через ({toString: () => '12'}).valueOf (), результатом будет объект с методом toString => {toString: ƒ}. 
// Это не примитив и теперь будет вызван метод toString. Поскольку объект уже имеет встроенный метод toString: () => '12', то будет вызван он, а не наследованный метод из прототипа.
// метод toString: () => '12' вернет строку '12'
// далее мы заново сравниваем '12' vs 12 => пр сравнении строки и числа строка будет преобразована к числу и результат будет число 12
// теперь операция сравнения начинается опять сначало и мы сравниваем 12 vs 12, это два одинаковыых типа поэтому сравнивается значение 12 == 12 true
// ответ: true 
====================================